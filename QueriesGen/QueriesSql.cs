// auto-generated by sqlc - do not edit
// ReSharper disable NotAccessedPositionalProperty.Global
// ReSharper disable UnusedAutoPropertyAccessor.Global
// ReSharper disable InconsistentNaming
using System.Collections.Generic;
using System.Threading.Tasks;
using System;
using Npgsql;
using NpgsqlTypes;

namespace QueriesGen;
public class QueriesSql(string connectionString)
{
    private const string CopyToInterimSql = "COPY interim_texts (text_id, source, source_updated_at, author, title, release_date, page, text) FROM STDIN (FORMAT BINARY)";
    public readonly record struct CopyToInterimArgs(int Text_id, string Source, DateTime Source_updated_at, string Author, string Title, DateTime Release_date, int Page, string Text);
    public async Task CopyToInterim(List<CopyToInterimArgs> args)
    {
        {
            await using var ds = NpgsqlDataSource.Create(connectionString);
            var connection = ds.CreateConnection();
            await connection.OpenAsync();
            await using var writer = await connection.BeginBinaryImportAsync(CopyToInterimSql);
            foreach (var row in args)
            {
                await writer.StartRowAsync();
                await writer.WriteAsync(row.Text_id, NpgsqlDbType.Integer);
                await writer.WriteAsync(row.Source, NpgsqlDbType.Varchar);
                await writer.WriteAsync(row.Source_updated_at, NpgsqlDbType.Date);
                await writer.WriteAsync(row.Author, NpgsqlDbType.Varchar);
                await writer.WriteAsync(row.Title, NpgsqlDbType.Varchar);
                await writer.WriteAsync(row.Release_date, NpgsqlDbType.Date);
                await writer.WriteAsync(row.Page, NpgsqlDbType.Integer);
                await writer.WriteAsync(row.Text, NpgsqlDbType.Text);
            }

            await writer.CompleteAsync();
            await connection.CloseAsync();
        }
    }

    private const string TruncateInterimSql = "TRUNCATE TABLE interim_texts";
    public async Task TruncateInterim()
    {
        {
            await using var connection = NpgsqlDataSource.Create(connectionString);
            await using var command = connection.CreateCommand(TruncateInterimSql);
            await command.ExecuteScalarAsync();
        }
    }

    private const string GetMaxIdSql = "SELECT COALESCE((SELECT MAX(text_id) FROM titles), 1)::INTEGER AS max_id";
    public readonly record struct GetMaxIdRow(int Max_id);
    public async Task<GetMaxIdRow?> GetMaxId()
    {
        {
            await using var connection = NpgsqlDataSource.Create(connectionString);
            await using var command = connection.CreateCommand(GetMaxIdSql);
            var reader = await command.ExecuteReaderAsync();
            if (await reader.ReadAsync())
            {
                return new GetMaxIdRow
                {
                    Max_id = reader.GetInt32(0)
                };
            }

            return null;
        }
    }

    private const string InsertMissingTitlesSql = "INSERT INTO titles (text_id, source, source_updated_at, author, title, release_date) SELECT  DISTINCT  i . text_id , i . source, source_updated_at, i . author, i . title, i . release_date  FROM  interim_texts  i  WHERE  NOT  EXISTS ( SELECT  1  FROM  titles  w  WHERE  SIMILARITY ( w . title, i . title ) >= @certainty :: float8 ) "; 
    public readonly record struct InsertMissingTitlesArgs(float Certainty);
    public async Task InsertMissingTitles(InsertMissingTitlesArgs args)
    {
        {
            await using var connection = NpgsqlDataSource.Create(connectionString);
            await using var command = connection.CreateCommand(InsertMissingTitlesSql);
            command.Parameters.AddWithValue("@certainty", args.Certainty);
            await command.ExecuteScalarAsync();
        }
    }

    private const string InsertMissingPagesSql = "INSERT INTO pages (text_id, page, text) SELECT  i . text_id , i . page, i . text  FROM  interim_texts  i  WHERE  NOT  EXISTS ( SELECT  1  FROM  pages  p  WHERE  p . text_id  =  i . text_id  AND  p . page  =  i . page ) AND  EXISTS ( SELECT  1  FROM  titles  t  WHERE  t . text_id  =  i . text_id ) "; 
    public async Task InsertMissingPages()
    {
        {
            await using var connection = NpgsqlDataSource.Create(connectionString);
            await using var command = connection.CreateCommand(InsertMissingPagesSql);
            await command.ExecuteScalarAsync();
        }
    }

    private const string SearchInTextsSql = "SELECT t.text_id, source, author, title, TS_HEADLINE ( 'english' , text, TO_TSQUERY (@query ), @options ) :: text  AS  matches  FROM  titles  t  JOIN  pages  p  ON  t . text_id  =  p . text_id  WHERE ( text @@ TO_TSQUERY ( @query ) OR  text2 @@ TO_TSQUERY ( @query ) ) LIMIT  @limit  "; 
    public readonly record struct SearchInTextsRow(int Text_id, string Source, string Author, string Title, string Matches);
    public readonly record struct SearchInTextsArgs(string Query, string Options, int Limit);
    public async Task<List<SearchInTextsRow>> SearchInTexts(SearchInTextsArgs args)
    {
        {
            await using var connection = NpgsqlDataSource.Create(connectionString);
            await using var command = connection.CreateCommand(SearchInTextsSql);
            command.Parameters.AddWithValue("@query", args.Query);
            command.Parameters.AddWithValue("@options", args.Options);
            command.Parameters.AddWithValue("@limit", args.Limit);
            var reader = await command.ExecuteReaderAsync();
            var result = new List<SearchInTextsRow>();
            while (await reader.ReadAsync())
            {
                result.Add(new SearchInTextsRow { Text_id = reader.GetInt32(0), Source = reader.GetString(1), Author = reader.GetString(2), Title = reader.GetString(3), Matches = reader.GetString(4) });
            }

            return result;
        }
    }
}